name: Verify UADE Version

on:
  push:
    branches: [ main ]
    paths:
      - 'Dockerfile'
      - '.github/workflows/verify-uade-version.yml'
  pull_request:
    branches: [ main ]
    paths:
      - 'Dockerfile'
  workflow_dispatch:
    inputs:
      image:
        description: 'Optional: image name or full image URL to verify (overrides Dockerfile.web)'
        required: false
        type: string

jobs:
  verify-version:
    name: Verify UADE Binary Version
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v3
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}

      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v3

      - name: Configure Docker for GCR
        run: gcloud auth configure-docker

      - name: Determine base image to verify
        id: base-image
        env:
          IMAGE: ${{ github.event.inputs.image || '' }}
        run: |
          # Use IMAGE env var set from github.event.inputs (defaults to empty string)
          # Otherwise, try to extract ARG BASE_IMAGE from Dockerfile.web (sanitize CRLFs).
          # If that fails, fall back to using the GCP project secret to build the GCR image URL.
          if [ -n "$IMAGE" ]; then
            # Treat the provided image input as a name[:tag] (regardless of whether
            # the caller provided a full path). Use only the last path segment so
            # callers can pass full URLs, repo/name:tag, or just name:tag.
            NAME_TAG=$(echo "$IMAGE" | awk -F'/' '{print $NF}')
            if echo "$NAME_TAG" | grep -q ':'; then
              :
            else
              # If no tag provided, default to known tag
              NAME_TAG="${NAME_TAG}:3.05-base.1"
            fi
            if [ -n "${{ secrets.GCP_PROJECT_ID }}" ]; then
              BASE_IMAGE="gcr.io/${{ secrets.GCP_PROJECT_ID }}/$NAME_TAG"
              echo "Using image name+tag with default GCR project: ${BASE_IMAGE}"
            else
              # No project secret, fall back to name:tag as given
              BASE_IMAGE="$NAME_TAG"
              echo "GCP_PROJECT_ID not set; using provided name:tag: ${BASE_IMAGE}"
            fi
          else
            BASE_IMAGE=$(grep -oP '^ARG\s+BASE_IMAGE=\K.*' Dockerfile.web | tr -d '\r' | xargs || true)
            if [ -n "${BASE_IMAGE}" ]; then
              echo "Extracted BASE_IMAGE from Dockerfile.web: ${BASE_IMAGE}"
              # If Dockerfile.web still contains an old hard-coded project (uade-docker),
              # rewrite it to use the repository secret project so CI pulls from the
              # intended GCP project instead of the deprecated uade-docker project.
              if echo "${BASE_IMAGE}" | grep -qE 'gcr\.io/uade-docker/'; then
                if [ -n "${{ secrets.GCP_PROJECT_ID }}" ]; then
                  BASE_IMAGE=$(echo "${BASE_IMAGE}" | sed "s|gcr.io/uade-docker/|gcr.io/${{ secrets.GCP_PROJECT_ID }}/|")
                  echo "Rewrote BASE_IMAGE to use secrets.GCP_PROJECT_ID: ${BASE_IMAGE}"
                else
                  echo "BASE_IMAGE points to gcr.io/uade-docker but GCP_PROJECT_ID secret is not set"
                fi
              fi
            else
              # Construct a reasonable default image URL using the GCP project secret and the known tag
              if [ -n "${{ secrets.GCP_PROJECT_ID }}" ]; then
                DEFAULT_TAG="3.05-base.1"
                BASE_IMAGE="gcr.io/${{ secrets.GCP_PROJECT_ID }}/uade-cli:${DEFAULT_TAG}"
                echo "No BASE_IMAGE in Dockerfile.web; falling back to gcr image: ${BASE_IMAGE}"
              else
                echo "No BASE_IMAGE found and GCP_PROJECT_ID secret is not set"
                exit 1
              fi
            fi
          fi

          echo "base_image=${BASE_IMAGE}" >> $GITHUB_OUTPUT

      - name: Pull pinned base image
        run: |
          echo "Attempting to pull base image: ${{ steps.base-image.outputs.base_image }}"
          # Fail the job if the pinned base image is not available in the registry.
          docker pull "${{ steps.base-image.outputs.base_image }}"

      - name: Extract UADE version from Dockerfile header
        id: dockerfile-version
        run: |
          # Extract version from Dockerfile header comment
          # Format: # UADE CLI Base Image v3.05-base.1
          DOCKERFILE_VERSION=$(grep -oP 'UADE CLI Base Image v\K[0-9.]+' Dockerfile | head -1)
          echo "version=${DOCKERFILE_VERSION}" >> $GITHUB_OUTPUT
          echo "Dockerfile version: ${DOCKERFILE_VERSION}"

      - name: Get UADE binary version from container
        id: container-version
        run: |
          # Get version from uade123 --version inside the pulled base image
          BASE_IMAGE="${{ steps.base-image.outputs.base_image }}"
          CONTAINER_VERSION=$(docker run --rm "$BASE_IMAGE" uade123 --version | grep -oP 'uade123 \K[0-9.]+')
          echo "version=${CONTAINER_VERSION}" >> $GITHUB_OUTPUT
          echo "Container version: ${CONTAINER_VERSION}"

      - name: Verify versions match
        run: |
          DOCKERFILE_VERSION="${{ steps.dockerfile-version.outputs.version }}"
          CONTAINER_VERSION="${{ steps.container-version.outputs.version }}"
          
          echo "Checking UADE version consistency..."
          echo "  Dockerfile declares: ${DOCKERFILE_VERSION}"
          echo "  Container binary is: ${CONTAINER_VERSION}"
          
          if [ "${DOCKERFILE_VERSION}" != "${CONTAINER_VERSION}" ]; then
            echo "❌ VERSION MISMATCH!"
            echo "   Dockerfile header shows v${DOCKERFILE_VERSION}"
            echo "   But container has uade123 ${CONTAINER_VERSION}"
            echo ""
            echo "Fix: Update Dockerfile header to match actual version"
            exit 1
          fi
          
          echo "✅ Version match verified: ${CONTAINER_VERSION}"

      - name: Verify UADE functionality
        run: |
          echo "Testing UADE help command..."
          BASE_IMAGE="${{ steps.base-image.outputs.base_image }}"
          docker run --rm "$BASE_IMAGE" uade123 --help > /dev/null 2>&1
          if [ $? -eq 0 ]; then
            echo "✅ UADE help command works"
          else
            echo "❌ UADE help command failed"
            exit 1
          fi

      - name: Test UADE conversion availability
        run: |
          echo "Checking UADE conversion capability..."
          # Disable errexit so a non-zero exit from docker doesn't terminate the step
          set +e
          BASE_IMAGE="${{ steps.base-image.outputs.base_image }}"
          docker run --rm "$BASE_IMAGE" uade123 -g > /dev/null 2>&1
          RC=$?
          # Re-enable errexit for the remainder of the script
          set -e

          # Accept exit code 0 (success) or 1 (expected when no file provided)
          if [ "$RC" -eq 0 ] || [ "$RC" -eq 1 ]; then
            echo "✅ UADE conversion flags available (exit code: $RC)"
          else
            echo "❌ UADE conversion flags unavailable (exit code: $RC)"
            exit 1
          fi

      - name: Print version details
        run: |
          echo "=== UADE Version Information ==="
          BASE_IMAGE="${{ steps.base-image.outputs.base_image }}"
          docker run --rm "$BASE_IMAGE" uade123 --version
          echo ""
          echo "=== Build timestamp ==="
          date -u +'%Y-%m-%d %H:%M:%S UTC'
