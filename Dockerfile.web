# Use versioned UADE CLI base image for stable, tested releases
# Pin specific versions to enable controlled updates and prevent breaking changes
# See docs/DOCKER_VERSIONING.md for versioning strategy
#
## Initial release: 3.05-base.1 (UADE binary version 3.05, 2025-11-11)
# Registry: GitHub Container Registry (GHCR) - ghcr.io/rib1/uade-cli:3.05-base.1
ARG BASE_IMAGE=ghcr.io/rib1/uade-cli:3.05-base.1
FROM ${BASE_IMAGE} AS uade-base

# Runtime stage - Add web server
FROM debian:stable-slim

# Build argument for git commit hash
ARG GIT_COMMIT=unknown
ENV GIT_COMMIT=${GIT_COMMIT}

# Install runtime dependencies + Python + tools for cloud environments
RUN apt-get update && apt-get install -y --no-install-recommends \
    libao4 \
    curl \
    ca-certificates \
    rsync \
    unzip \
    lhasa \
    python3 \
    python3-pip \
    python3-venv \
    flac \
    && rm -rf /var/lib/apt/lists/*

# Copy UADE binaries and libraries from base image
COPY --from=uade-base /usr/local/bin/uade123 /usr/local/bin/
COPY --from=uade-base /usr/local/share/uade /usr/local/share/uade
COPY --from=uade-base /usr/local/lib/ /usr/local/lib/

# Update library cache
RUN ldconfig

# Create Python virtual environment and install dependencies
RUN python3 -m venv /opt/venv
ENV PATH="/opt/venv/bin:$PATH"
RUN pip install --no-cache-dir \
    flask==3.0.0 \
    werkzeug==3.0.1 \
    requests==2.31.0 \
    gunicorn==21.2.0 \
    fsspec==2025.10.0

# Create app directory structure and non-root user
RUN mkdir -p /app /tmp/modules /tmp/converted && \
    useradd -m -u 1000 -s /bin/bash uade && \
    chown -R uade:uade /app /opt/venv && \
    chmod -R 777 /tmp/modules /tmp/converted

# Copy web application
COPY web/ /app/

WORKDIR /app

# Switch to non-root user
USER uade

# Set environment variables for cloud deployment
ENV FLASK_APP=server.py
ENV FLASK_ENV=production
ENV PYTHONUNBUFFERED=1
ENV PORT=5000

# Expose port (cloud platforms read this)
EXPOSE 5000

# Health check for container orchestration
HEALTHCHECK --interval=30s --timeout=3s --retries=3 \
  CMD curl -f http://localhost:5000/health || exit 1

# Use gunicorn for production (better than Flask dev server for cloud)
# Single worker to minimize memory usage for large file streaming
CMD ["gunicorn", "--bind", "0.0.0.0:5000", "--workers", "1", "--threads", "4", "--timeout", "300", "--graceful-timeout", "300", "--keep-alive", "5", "--worker-class", "gthread", "--access-logfile", "-", "--error-logfile", "-", "server:app"]
